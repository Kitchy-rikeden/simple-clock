#pragma config FEXTOSC = OFF    // FEXTOSC External Oscillator mode Selection bits (Oscillator not enabled)
#pragma config RSTOSC = HFINT1  // Power-up default value for COSC bits (HFINTOSC (1MHz))
#pragma config CLKOUTEN = OFF   // Clock Out Enable bit (CLKOUT function is disabled; I/O or oscillator function on OSC2)
#pragma config CSWEN = ON       // Clock Switch Enable bit (Writing to NOSC and NDIV is allowed)
#pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable (Fail-Safe Clock Monitor is disabled)
#pragma config MCLRE = ON       // Master Clear Enable bit (MCLR/VPP pin function is MCLR; Weak pull-up enabled)
#pragma config PWRTE = OFF      // Power-up Timer Enable bit (PWRT disabled)
#pragma config WDTE = OFF       // Watchdog Timer Enable bits (WDT disabled; SWDTEN is ignored)
#pragma config LPBOREN = OFF    // Low-power BOR enable bit (ULPBOR disabled)
#pragma config BOREN = OFF      // Brown-out Reset Enable bits (Brown-out Reset disabled)
#pragma config BORV = LOW       // Brown-out Reset Voltage selection bit (Brown-out voltage (Vbor) set to 2.45V)
#pragma config PPS1WAY = ON     // PPSLOCK bit One-Way Set Enable bit (The PPSLOCK bit can be cleared and set only once; PPS registers remain locked after one clear/set cycle)
#pragma config STVREN = OFF     // Stack Overflow/Underflow Reset Enable bit (Stack Overflow or Underflow will not cause a Reset)
#pragma config DEBUG = OFF      // Debugger enable bit (Background debugger disabled)
#pragma config WRT = OFF        // User NVM self-write protection bits (Write protection off)
#pragma config LVP = OFF        // Low Voltage Programming Enable bit (High Voltage on MCLR/VPP must be used for programming.)
#pragma config CP = OFF         // User NVM Program Memory Code Protection bit (User NVM code protection disabled)
#pragma config CPD = OFF        // Data NVM Memory Code Protection bit (Data NVM code protection disabled)

#include <xc.h>
#include "sed1520.h"
#include "i2c.h"
#include "bme280.h"

#define _XTAL_FREQ 125000

#define DS 0b1101000

enum Mode { SEC = 0,  MIN, HOUR, DAY, DATE, MONTH, YEAR, IDLE = 255} mode;

const char background[488] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x70,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x70,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xE0,0xE0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x3A,0x44,0x44,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x46,0x30,0x0C,0x62,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7F,0x04,0x04,0x78,0x00,0x7F,0x11,0x11,0x0E,0x00,0x20,0x54,0x54,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
const char largeNum[36*11] = {0x00,0xE0,0xFC,0x7E,0x0F,0x07,0x07,0x07,0x0F,0x7E,0xFC,0xE0,0x00,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x01,0x07,0x07,0x0E,0x0E,0x0E,0x07,0x07,0x01,0x00,0x00,0x00,0x00,0x18,0x18,0x1C,0xFE,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x00,0x00,0x00,0x00,0x00,0xF8,0xFE,0x0E,0x07,0x03,0x07,0x0F,0xFE,0xFC,0x00,0x00,0x00,0x00,0x80,0xC0,0xE0,0xF8,0x3C,0x1F,0x07,0x03,0x00,0x00,0x0E,0x0F,0x0F,0x0D,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x00,0x00,0x38,0x3E,0x0E,0x07,0x03,0x03,0x0F,0xFE,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0x0E,0x1F,0xFB,0xF1,0xC0,0x00,0x00,0x03,0x07,0x0E,0x0E,0x0E,0x0E,0x07,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0xC0,0xF0,0x7C,0x1F,0xFF,0xFF,0x00,0x00,0x00,0xF0,0xFC,0xDF,0xC7,0xC1,0xC0,0xC0,0xFF,0xFF,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x0F,0x00,0x00,0x00,0x00,0xFF,0xFF,0x07,0x87,0x87,0x87,0x87,0x07,0x07,0x00,0x00,0x00,0x07,0x07,0x03,0x01,0x01,0x01,0x03,0xFF,0xFE,0xF8,0x00,0x00,0x03,0x07,0x06,0x0E,0x0E,0x0E,0x07,0x07,0x01,0x00,0x00,0x00,0xF0,0xFC,0x1E,0x87,0x83,0x83,0x87,0x3E,0x3C,0x00,0x00,0x7E,0xFF,0xFF,0x07,0x03,0x03,0x03,0x07,0xFF,0xFC,0xF0,0x00,0x00,0x01,0x03,0x07,0x0E,0x0E,0x0E,0x0F,0x07,0x03,0x00,0x00,0x00,0x00,0x07,0x07,0x07,0x07,0x07,0x07,0xC7,0xFF,0x3F,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xF0,0xFE,0x3F,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x0F,0x0F,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFE,0x0F,0x03,0x03,0x03,0x0F,0xFE,0xFC,0x00,0x00,0xC0,0xF1,0xFB,0x1F,0x0E,0x0E,0x0E,0x1F,0xFB,0xF1,0xC0,0x00,0x00,0x03,0x07,0x0E,0x0E,0x0E,0x0E,0x0E,0x07,0x03,0x00,0x00,0xE0,0xFC,0xFE,0x0F,0x03,0x03,0x07,0x0E,0xFC,0xF8,0xC0,0x00,0x01,0x0F,0x1F,0x38,0x30,0x30,0x18,0x0C,0xFF,0xFF,0xFF,0x00,0x00,0x03,0x07,0x0E,0x0E,0x0E,0x0E,0x07,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
//10: ':', 11: ' '
const char smallNum[5*11] = {0x00,0x3E,0x41,0x41,0x3E,0x00,0x00,0x02,0x7F,0x00,0x00,0x62,0x51,0x49,0x46,0x00,0x22,0x41,0x49,0x36,0x00,0x1E,0x11,0x7F,0x10,0x00,0x2F,0x49,0x49,0x31,0x00,0x3E,0x49,0x49,0x32,0x00,0x01,0x71,0x0D,0x03,0x00,0x36,0x49,0x49,0x36,0x00,0x26,0x49,0x49,0x3E,0x00,0x00,0x00,0x00,0x00};
//10: ., 11: ℃, 12: %, 13:h, 14:P, 15:a, 16:/ 17:' '
const char dayData[] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0xFF,0x11,0x11,0x11,0x11,0x11,0x11,0xFF,0xFF,0x00,0x00,0x00,0x40,0x60,0x38,0x1F,0x07,0x01,0x01,0x01,0x01,0x41,0x41,0x7F,0x7F,0x00,0x00,0x00,0x80,0xC0,0x70,0x30,0x00,0x80,0xFF,0xFF,0x80,0x00,0x40,0x60,0x30,0x10,0x00,0x40,0x40,0x60,0x30,0x18,0x0E,0x07,0x01,0x01,0x07,0x0E,0x18,0x30,0x60,0x40,0x40,0x10,0x10,0x10,0x10,0xD0,0xF0,0x30,0xFF,0xFF,0xF8,0xC0,0xC0,0x60,0x30,0x18,0x08,0x10,0x18,0x0C,0x07,0x03,0x40,0x40,0x7F,0x7F,0x00,0x01,0x03,0x06,0x0C,0x18,0x10,0x08,0x08,0x08,0x08,0x08,0xC8,0xE8,0xFF,0xFF,0xE8,0xC8,0x08,0x08,0x08,0x08,0x08,0x10,0x18,0x0C,0x06,0x03,0x01,0x00,0x7F,0x7F,0x00,0x01,0x03,0x06,0x0C,0x18,0x10,0x40,0x40,0x60,0x30,0x58,0x4C,0x46,0xC3,0xC3,0x46,0x4C,0x58,0x30,0x60,0x40,0x40,0x40,0x42,0x42,0x4A,0x7A,0x72,0x42,0x7F,0x7F,0x42,0x62,0x7A,0x5A,0x42,0x42,0x40,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0xFE,0xFE,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x7F,0x7F,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,0xFE,0xFE,0x82,0x82,0x82,0x82,0x82,0x82,0x82,0xFE,0xFE,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x7F,0x7F,0x00,0x00,0x00};
//0: ' ', 1: 月, ... 7: 日
char dateTime[7];
int temp, hum, pres;

const char maxList[] = {0x60, 0x60, 0x24, 0x08, 0x32, 0x13, 0xA0};  //BCDフォーマット

char measureFlag = 0;   

void PrintLargeNum(char add, char num, char mask){
    int offset = 36*num;
    
    for(char i=0; i<3; i++){
        Sed_SetAddress(i, 12*add);
        
        for(char j=0; j<12; j++){
            Sed_Dat(largeNum[offset] ^ mask);
            offset++;
        }
    }
}
void PrintSmallNum(char num, char mask){
    int offset = 5*num;
    
    for(char i=0; i<5; i++){
        Sed_Dat(smallNum[offset + i] ^ mask);
    }
}
void PrintDay(char mask){
    int offset = 32*dateTime[DAY];
    
    for(char i=0; i<2; i++){
        Sed_SetAddress(2+i, 104);
        
        for(char j=0; j<16; j++){
            Sed_Dat(dayData[offset] ^ mask);
            offset++;
        }
    }
}
void Prints(char target, char mask){
    char buf;
    
    switch(target){
        case SEC:
            PrintLargeNum(6, (dateTime[SEC] >> 4) & 0x0F, mask);    //10の位
            PrintLargeNum(7, dateTime[SEC] & 0x0F, mask);           // 1の位
            break;
            
        case MIN:
            PrintLargeNum(3, (dateTime[MIN] >> 4) & 0x0F, mask);    //10の位
            PrintLargeNum(4, dateTime[MIN] & 0x0F, mask);           // 1の位
            break;
            
        case HOUR:
            buf = (dateTime[HOUR] >> 4) & 0x0F;             //10の位
                if(buf == 0) buf = 10;                      // 0消し
            PrintLargeNum(0, buf, mask);
            PrintLargeNum(1, dateTime[HOUR] & 0x0F, mask);  // 1の位
            break;
            
        case DAY:
            PrintDay(mask);
            break;
            
        case DATE:
            Sed_SetAddress(1, 112);
            buf = (dateTime[DATE] >> 4) & 0x0F;
                if(buf == 0) buf = 10;
            PrintSmallNum(buf, mask);
            PrintSmallNum(dateTime[DATE] & 0x0F, mask);
            break;
            
        case MONTH:
            Sed_SetAddress(1, 97);
            buf = (dateTime[MONTH] >> 4) & 0x0F;
                if(buf == 0) buf = 10;
            PrintSmallNum(buf, mask);
            PrintSmallNum(dateTime[MONTH] & 0x0F, mask);
            break;
            
        case YEAR:
            Sed_SetAddress(0, 102);
            PrintSmallNum(2, mask);
            PrintSmallNum(0, mask);
            PrintSmallNum((dateTime[YEAR] >> 4) & 0x0F, mask);
            PrintSmallNum(dateTime[YEAR] & 0x0F, mask);
            break;
    }
}

void GetDateTime(){         //DS1307のアドレス0-6を取得しdataTime[]に格納
    SendI2C(DS, 0);
    GetDataI2C(DS, dateTime, 7);
}
void SetDateTime(){
    for(char i=0; i<7; i++){
        CmdI2C(DS, i, dateTime[i]);
    }
    CmdI2C(DS, 7, 0x10);    // 1Hz output
}
void BCDincrement(char* c){
    (*c)++;
    if((*c & 0x0F) == 10)
        *c += 6;            //繰り上がり -10 + 16
}
void PrintWeather(){
    char buf[4];
    
    //気温
    buf[0] = temp / 100;                //100の位
        if(buf[0] == 0) buf[0] = 10;    //  0消し
    buf[1] = (temp / 10) % 10;          // 10の位
    buf[2] = temp % 10;                 //  1の位
    
    Sed_SetAddress(3, 6);
    PrintSmallNum(buf[0], 0);
    PrintSmallNum(buf[1], 0);
    Sed_SetAddress(3, 18);
    PrintSmallNum(buf[2], 0);
    
    //湿度
    buf[0] = hum / 100;
        if(buf[0] == 0) buf[0] = 10;
    buf[1] = (hum / 10) % 10;
        if((buf[0] == 10) && (buf[1] == 0)) buf[1] = 10;
    buf[2] = hum % 10;
    
    Sed_SetAddress(3, 33);
    for(char i=0; i<3; i++){
        PrintSmallNum(buf[i], 0);
    }
    
    //気圧
    buf[0] = pres / 1000;
        if(buf[0] == 0) buf[0] = 10;
    buf[1] = (pres / 100) % 10;
    buf[2] = (pres / 10) % 10;
    buf[3] = pres % 10;
    
    Sed_SetAddress(3, 61);
    for(char i=0; i<4; i++){
        PrintSmallNum(buf[i], 0);
    }
}

void Init(){
    TRISA  = 0b00001011;
    ANSELA = 0;
    WPUA   = 0b00001011;
    PORTA  = 0;
    
    TRISB  = 0b11110000;
    ANSELB = 0;
    WPUB   = 0b10100000;
    PORTB  = 0;
    
    TRISC  = 0;
    ANSELC = 0;
    WPUC   = 0;
    PORTC  = 0;
    
    PMD0 = 0b01111110;  //Enabled Periferals:
    PMD1 = 0xFF;        // SystemClock
    PMD2 = 0xFF;        // IOC
    PMD3 = 0xFF;        // MSSP1
    PMD4 = 0b11111101;
    PMD5 = 0xFF;
    
    IOCAN = 0b00000011;
    IOCAP = 0b00000011;
    IOCBN = 0b10000000;
    IOCIE = 1;
    
    PEIE = 1;
}

void main(void) {
    Init();
    
    Sed_Init();
    for(int i=0; i<488; i++){
        Sed_Dat(background[i]);
    }
    
    I2C_Master_Init(10000);
    bme_Init();
    measureFlag = 1;
    
    GetDateTime();
    for(char i = SEC; i<= YEAR; i++){
        Prints(i, 0);
    }
    
    //クロックダウン、割込み開始
    GIE = 1;
    OSCFRQbits.HFFRQ = 0b0000;  // 1 MHz
    OSCCON1bits.NDIV = 0b0011;  // 1/8 = 125 kHz
    
    while(1){
        if(measureFlag){
            measureFlag = 0;
            bme_ForceMeasurement(&temp, &hum, &pres);
            PrintWeather();
        }
        SLEEP();                //消費電力低減（効果あるのかは不明）
    }
}

void __interrupt isr(){
    GIE = 0;
    if(IOCAFbits.IOCAF0){       //START
        IOCAFbits.IOCAF0 = 0;
        
        static char sw0 = 1;
        
        __delay_ms(1);                  //チャタリング回避
        if((RA0 == 0) && (sw0 == 1)){   //
            
            if(mode == IDLE){           //時刻設定開始
                mode = SEC;
                Prints(mode, 0xFF);     //マスク
                IOCBNbits.IOCBN7 = 0;   //クロック入力停止
            }
            
            else if(mode == YEAR){      //時刻設定完了
                Prints(mode, 0);        //マスク解除
                SetDateTime();
                
                mode = IDLE;
                IOCBNbits.IOCBN7 = 1;   //クロック入力再開
            }
            
            else{
                Prints(mode, 0);        //マスク解除
                mode++;                 //設定項目移動
                Prints(mode, 0xFF);     //マスク
            }
            sw0 = 0;
        }
        else if((RA0 == 1) && (sw0 == 0)){
            sw0 = 1;
        }
    }
    
    if(IOCAFbits.IOCAF1){       //SELECT
        IOCAFbits.IOCAF1 = 0;
        
        static char sw1 = 1;
        
        __delay_ms(1);
        if((RA1 == 0) && (sw1 == 1)){
            
            if(mode != IDLE){
                BCDincrement(&dateTime[mode]);
                
                if(dateTime[mode] >= maxList[mode])
                    dateTime[mode] = 0;
                
                Prints(mode, 0xFF);
            }
            sw1 = 0;
        }
        else if((RA1 == 1) && (sw1 == 0)){
            sw1 = 1;
        }
    }
    
    if(IOCBFbits.IOCBF7){       //1Hzクロック入力
        IOCBFbits.IOCBF7 = 0;
        
        BCDincrement(&dateTime[SEC]);
        
        if(dateTime[SEC] == 0x60){
            dateTime[SEC] = 0;
            BCDincrement(&dateTime[MIN]);
            
            if(dateTime[MIN] == 0x60){
                dateTime[MIN] = 0;
                BCDincrement(&dateTime[HOUR]);
                
                if(dateTime[HOUR] == 0x24){
                    dateTime[HOUR] = 0;
                    GetDateTime();
                    for(char i=DAY; i<= YEAR; i++)
                        Prints(i, 0);
                }
                Prints(HOUR, 0);
            }
            Prints(MIN, 0);
            measureFlag = 1;    //1分ごとに気象データ測定
        }
        
        Prints(SEC, 0);
        
    }
    GIE = 1;
}